---
title: "Storms"
subtitle: "A NOAA database analysis for Health and Economic consequences"
author: "Mathieu C."
date: "2 octobre 2019"
output: 
  html_document:
    keep_md: true
---

## Synopsis
The file "Storm Data" comes from the U.S. National Oceanic and Atmospheric  
Administration's (NOAA) and was accessible at [this url](https://d396qusza40orc.cloudfront.net/repdata%2Fdata%2FStormData.csv.bz2) on oct. 2nd 2019.  
  
The goal of the assessment is to produce a report that points at the most  
harmful and most costly meteorological events across the US for the years we  
have access to (1950 - 2011).  
  
More details can be found in the README.md file at [this GitHub url](https://github.com/Ravenpsycho/RepData_PeerAssessment2)

## Data Processing

### Data Loading  
We will begin by taking a look at the data:
```{r cache=TRUE}
# Downloading file (47Mb, might take a while depending on the connection and speeds)
# note that this step is cached and will be executed much faster if repeated:
myurl <- "https://d396qusza40orc.cloudfront.net/repdata%2Fdata%2FStormData.csv.bz2"
if (!file.exists("Storm_Data.csv.bz2")){
        download.file(myurl, destfile = "Storm_Data.csv.bz2")
}
# Reading in the dataframe, again, might take a while.
if (!exists("StormData")){
        StormData <- read.csv("Storm_Data.csv.bz2")
}
str(StormData)
```
  
### Check for NA's
  
From the above call to `str()` function, the database seems pretty organized.  
Let's check for missing values:
```{r}
na_check <- lapply(StormData, is.na)
na_check <- lapply(na_check, sum)
sort(unlist(na_check), decreasing = T)
```
  
We can see that the database is an "all or nothing" type: either a variable  
has (almost) all it's values filled in, or almost all the data is missing.  
  
Fortunately, in the "missing" camp, we have only two variables `F` and  
`COUNTYENDN`. Since these variables don't seem to be relevant to the questions  
at hands, we won't take further actions in their regard.  
  
### Data modifications

This will require some packages, let's load them:
```{r}
library(dplyr)
library(ggplot2)
library(reshape2)
library(pdftools)
library(stringr)
library(stringdist)
```
  
Let's first create (...)
<<<<<<< HEAD
```{r cache=TRUE}
testdate <- as.POSIXlt(
                as.character(StormData$BGN_DATE),
                format = "%m/%d/%Y %H:%M:%S") > "1996-01-01"
conditions <- (StormData$CROPDMG > 0 | StormData$PROPDMG > 0 |
        StormData$INJURIES > 0 | StormData$FATALITIES > 0) & testdate 
StormData_mod <- subset(StormData, subset = conditions)
StormData_mod <- StormData_mod[,c("EVTYPE","INJURIES", "FATALITIES", "CROPDMG", "CROPDMGEXP",
                              "PROPDMG", "PROPDMGEXP")]

```
  
After some exploration, we can notice something about `EVTYPE`. There are  
duplicates. For example: `THUNDERSTORM WIND` appears a whole lot of times under  
slightly different names.    
This is a problem. Events will need to be grouped under the official  
48 names below (found in the pdf file in code):  
  
```{r}
pdf_url <- paste0("https://d396qusza40orc.cloudfront.net/",
                  "repdata%2Fpeer2_doc%2Fpd01016005curr.pdf")
my_pdf <- 
        paste0(pdf_text(pdf_url)[c(2:4)])
my_str <- unlist(strsplit(my_pdf, "\\r\\n"))
my_str <- my_str[47:128]
my_str_short <- str_match(string = my_str, pattern = "7.([0-9]+)[.]? +(.*?) *(?:[(][A-Z][)])? *[.]{3,}")
my_str_short <- toupper(my_str_short[!is.na(my_str_short[,3]),3])
rm(my_pdf, my_str)
print(my_str_short)
```

After (*lots*) of trial and error, one of the main issues to match is the fact  
that some of the terms are abbreviated, like `TSTM` and `FLD`.  
  
<<<<<<< HEAD
We will try to fix them before the attempt. 
  
While we're at it, there's a few strings that start with `NON` something.  

We'll try to catch them as well.  

```{r}
patterns <- c("FLD", "NON-? ?\\w*", "TSTM", "URBAN/SML STREAM", "Ice jam flood [(]minor")
replacements <-  c("FLOOD", "", "THUNDERSTORM", "", "FLOOD")

for (i in 1:length(patterns)){
        StormData_mod$EVTYPE <- 
                gsub(patterns[i], replacements[i],
                     as.character(StormData_mod$EVTYPE), ignore.case = T)
}
StormData_mod$EVTYPE <- factor(StormData_mod$EVTYPE, levels = unique(StormData_mod$EVTYPE))
grep("STREAM FLOOD", StormData_mod$EVTYPE)
```



```{r}
## The matching attempt:
matches <- amatch(toupper(StormData_mod$EVTYPE), my_str_short, method = "lv", maxDist = 12)
df_test_amatch <- data.frame(EVTYPE = StormData_mod$EVTYPE, 
                             RESULT = my_str_short[matches])
sum(is.na(df_test_amatch$RESULT))
amatch_14 <- which(is.na(df_test_amatch$RESULT))
df_test_amatch[amatch_14,]
```


This is also a problem because it appears pretty high in the list of harmful  
and costly events. I will now modify them to gather all these events under a  
new name, `TSTM WIND COMBINED`.



```{r}
wind_logical <- grepl("^ *(T.*ST.*M)+ *WIND(S)*$", as.character(StormData_mod$EVTYPE), ignore.case = T)
names_tstm <- unique(as.character(StormData_mod[wind_logical, "EVTYPE"]))
print(names_tstm)
```

```{r}
StormData_mod[wind_logical,]$EVTYPE <- names_tstm[1]
level_nb <- which(levels(StormData_mod$EVTYPE) == names_tstm[1])
levels(StormData_mod$EVTYPE)[level_nb] <- "TSTM WIND COMBINED"
unique(as.character(StormData_mod[wind_logical, "EVTYPE"]))
```
  
Much better. But there's also a problem with `HEAT`, we'll proceed the very  
same way, further altering `StormData_mod`:
```{r}
heat_logical <- grepl("((?!.*DROUGHT/?) *HEAT.*|.*HEAT *(?!.*DROUGHT/?))", 
                      as.character(StormData_mod$EVTYPE),
                      perl = TRUE,
                      ignore.case = T)
names_heat <- unique(as.character(StormData_mod[heat_logical, "EVTYPE"]))
print(names_heat)
```

```{r}
StormData_mod$EVTYPE[heat_logical] <- names_heat[1]
level_nb <- which(levels(StormData_mod$EVTYPE) == names_heat[1])
levels(StormData_mod$EVTYPE)[level_nb] <- "HEAT COMBINED"
unique(as.character(StormData_mod[heat_logical, "EVTYPE"]))
```
Lastly, we will do the same with `FLOODS`:

```{r}
flood_logical <- grepl("^ *(FLOOD */)? *(FLASH|)+ *FLOOD(S)*(ING)*$", as.character(StormData_mod$EVTYPE),
                      ignore.case = T)
names_flood <- unique(as.character(StormData_mod[flood_logical, "EVTYPE"]))
print(names_flood)
```
```{r}
StormData_mod$EVTYPE[flood_logical] <- names_flood[1]
level_nb <- which(levels(StormData_mod$EVTYPE) == names_flood[1])
levels(StormData_mod$EVTYPE)[level_nb] <- "FLOOD COMBINED"
unique(as.character(StormData_mod[flood_logical, "EVTYPE"]))
```


## Data Analysis
  
Now we have the tools to create a new dataframe, with data grouped by `EVTYPE`
(event type) and we'll take a look at the highest means of fatalities and injuries.
```{r}
health_by_event <- StormData_mod %>%
        group_by(EVTYPE) %>%
        summarize(mean.fatalities = mean(FATALITIES, na.rm = T),
                  mean.injuries = mean(INJURIES, na.rm = T),
                  total.means = mean.fatalities + mean.injuries,
                  occurences = n()) %>%
        arrange(desc(total.means))
head(health_by_event, 10)
```
  
In our question we want to know how harmful an event is to population.  
My first thought was to sort the events by their total means (injuries  
and fatalities) combined as in the top 10 above.  
  
However, we first have to make sure that these events occur regularly to avoid  
putting too much weight into a deadly, harmful but also very unlikely event  
  
Let's see what the top most frequent events a.k.a. `occurences` looks like:
```{r}
head(health_by_event[order(health_by_event$occurences, decreasing = T),], 10)
```
This is interesting. We can see that some newcomers like `HAIL` or  
`TSTM WIND COMBINED` occur lots of times and they **are** harmful, not top  
10 harmful but still.  
  
Let's try creating an `index` variable. It will be the product of `occurences`  
by `total.means`.  

*Why?*  
  
Because this way, if an event is occuring a very low amount of time but has  
a very harmful outcome, it will be on par with a less harmful event that  
happens much more frequently. We will log(10) this index to avoid working  
with huge numbers.  
  
Let's do this and have a look:
```{r}
health_by_event <- transform(health_by_event, 
                         index = log((occurences * total.means), 10))
head(health_by_event[order(desc(health_by_event$index)),], 10)
```


```{r}
plotpop <- head(health_by_event[order(desc(health_by_event$index)),], 20)
plotpop$EVTYPE <- factor(plotpop$EVTYPE, levels = as.character(plotpop$EVTYPE))

warncolors <- colorRampPalette(c("red", "gold3"))
g1 <- ggplot(plotpop[c(1:6)],
             aes(x=EVTYPE, y = index, fill = EVTYPE))
g1 + geom_bar(stat = "identity", position = "dodge") +
        ylab("Health issues index")+
        xlab(element_blank())+
        theme(legend.position = "none")+
        scale_fill_manual(values = warncolors(20))+
        theme(axis.text.x = element_text(angle = 45, hjust = 0.95)) +
        labs(title = paste0("Top 20 events in decreasing order of Health issues",
                            " index (HII).\n HII = mean of injuries + mean ",
                            " of fatalities * total occurences\nData for ",
                            "years 1996 to 2011"))
        
```
  
Let's do the same with cost, using two new variables, `PROPDMG` and `CROPDMG`,  
holding numbers for *property damage* and *crop damage*, respectively, they  
first have to be ajusted with their exponent `EXP` counteparts:
```{r}
v_pattern <- c("[0-9]", "^$", "[+]", "[?-]", "[hH]", "[kK]", "[mM]", "[Bb]") 
v_repl <- c("10", "0", "1", "0", "100", "1000", "1000000", "1000000000")
## Modifying CROPDMGEXP
StormData_mod$CROPDMGEXP <- as.character(StormData_mod$CROPDMGEXP)
StormData_mod$PROPDMGEXP <- as.character(StormData_mod$PROPDMGEXP)

for (i in 1:8){
        StormData_mod$CROPDMGEXP <-
                gsub(v_pattern[i], v_repl[i], StormData_mod$CROPDMGEXP)
        StormData_mod$PROPDMGEXP <- 
                gsub(v_pattern[i], v_repl[i], StormData_mod$PROPDMGEXP)
} 
sum(!is.numeric(as.numeric(StormData_mod$CROPDMGEXP)))
sum(!is.numeric(as.numeric(StormData_mod$PROPDMGEXP)))

StormData_mod$CROPDMGEXP <- as.numeric(StormData_mod$CROPDMGEXP)
StormData_mod$PROPDMGEXP <- as.numeric(StormData_mod$PROPDMGEXP)
```




```{r}
cost_by_event <- StormData_mod %>%
        group_by(EVTYPE) %>%
        summarise(mean.prop = mean(PROPDMG * PROPDMGEXP, na.rm = T),
                  mean.crop = mean(CROPDMG * CROPDMGEXP, na.rm = T),
                  mean.combi = mean.crop + mean.prop,
                  occurences = n(),
                  index = log(mean.combi*occurences, 10)) %>%
        arrange(desc(index))
head(cost_by_event[order(desc(cost_by_event$mean.combi)),])
```
If we arrange the data by `mean.combi` (as seen above), we can see that the  
most costly events have a very low occurence. Since the goal of this analysis  
is to produce a report supposedly for preparation towards events, the formerly  
used method of creating an index to weight events by `occurences` seems about  
right.
```{r}
head(cost_by_event, 20)
```

```{r}
plotpop2 <- head(cost_by_event[order(desc(cost_by_event$index)),], 20)
plotpop2$EVTYPE <- factor(plotpop2$EVTYPE, levels = as.character(plotpop2$EVTYPE))

prettycolors2 <- colorRampPalette(c("darkgreen", "springgreen"))
g2 <- ggplot(plotpop2[c(1:6)],
             aes(x=EVTYPE, y = index, fill = EVTYPE))
g2 + geom_bar(stat = "identity", position = "dodge") +
        ylab("Cost Index")+
        xlab(element_blank())+
        theme(legend.position = "none")+
        scale_fill_manual(values = prettycolors2(20))+
        theme(axis.text.x = element_text(angle = 65, hjust = 0.95)) +
        labs(title = paste0("Top 20 events in decreasing order of Cost",
                            " Index (CI).\n CI = mean of propriety damage +",
                            " mean of crop damage ",
                            "* total occurences\nData for ",
                            "years 1996 to 2011"))
        
```
  
I will rest my case here. Further steps should be taken to be able to consider  
this work for anything else than a simple assessment in the JH Datascience  
course:  
  
* In depth cleaning of the `EVTYPE` variable to ensure the best merge of duplicates.
* Regional repartition to further affinate the specific risk potential.
* Ajusting the index, especially for health, to reflect the true impact on  
a community